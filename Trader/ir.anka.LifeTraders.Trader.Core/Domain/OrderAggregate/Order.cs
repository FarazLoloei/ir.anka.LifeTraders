using Castle.Core.Internal; using ir.anka.LifeTraders.SharedKernel; using ir.anka.LifeTraders.SharedKernel.Abstraction; using ir.anka.LifeTraders.SharedKernel.Exceptions; using ir.anka.LifeTraders.Trader.Core.Domain.AccountAggregate.Exceptions; using ir.anka.LifeTraders.Trader.Core.Domain.OrderAggregate.Abstraction; using ir.anka.LifeTraders.Trader.Core.Domain.OrderAggregate.Enums;  namespace ir.anka.LifeTraders.Trader.Core.Domain.OrderAggregate;  public class Order : EntityBase, IAggregateRoot<Order> {     private readonly IOrderValidator orderValidator;      public Order(string login, long ticket, PlacedType placedType, OrderType orderType, DealType dealType, string symbol,         OrderState orderState, Direction direction, IOrderValidator orderValidator)     {         Id = Guid.NewGuid();         Login = login;         Ticket = ticket;         PlacedType = placedType;         OrderType = orderType;         DealType = dealType;         Symbol = symbol;         State = orderState;         Direction = direction;         this.orderValidator = orderValidator;         Validate();      }      protected Order()     {     }      public string Login { get; private set; }      public long Ticket { get; private set; }      public double Profit { get; private set; } = 0;      public double ProfitRate { get; private set; } = 0;      public double Swap { get; private set; } = 0;      public double Commission { get; private set; } = 0;      public double ClosePrice { get; private set; } = 0;      public DateTime? CloseTime { get; private set; }      public double CloseVolume { get; private set; } = 0;      public string? CloseComment { get; private set; }      public double OpenPrice { get; private set; } = 0;      public DateTime OpenTime { get; private set; }      public double Lots { get; private set; } = 0;      public double ContractSize { get; private set; } = 0;      public long ExpertId { get; private set; } = 0;      public PlacedType PlacedType { get; private set; }      public OrderType OrderType { get; private set; }      public DealType DealType { get; private set; }      public string Symbol { get; private set; } = string.Empty;      public string? Comment { get; private set; }      public OrderState State { get; private set; }      public double StopLoss { get; private set; } = 0;      public double TakeProfit { get; private set; } = 0;      public int RequestId { get; private set; } = 0;      public int Digits { get; private set; } = 0;      public double StopLimitPrice { get; private set; } = 0;      public ExpirationType ExpirationType { get; private set; }      public DateTime ExpirationTime { get; private set; }      public FillPolicy FillPolicy { get; private set; }      public Direction Direction { get; private set; }      public double Price { get; private set; } = 0;      public ulong Volume { get; private set; } = 0;      public double VolumeRate { get; private set; } = 0;      public long PositionTicket { get; private set; } = 0;      public int MoneyDigits { get; private set; } = 0;      public double FreeProfit { get; private set; } = 0;      public double TrailRounder { get; private set; } = 0;       public void Validate()     {         var validateConditionsResult = ValidateConditions();          if (!validateConditionsResult.IsNullOrEmpty())         {             throw new AccountValidateException(validateConditionsResult);         }     }      private IEnumerable<Exception> ValidateConditions()     {         if (string.IsNullOrEmpty(Login))         {             yield return new PropertyNullOrEmptyException(nameof(Ticket));         }          if (string.IsNullOrEmpty(Symbol))         {             yield return new PropertyNullOrEmptyException(nameof(Symbol));         }          if (Ticket < 1)         {             yield return new PropertyValueIsInvalidException(nameof(Ticket));         }     } }